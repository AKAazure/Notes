## 第二章 程序结构

### 2.1. 命名

- Go语言中的**关键字**有25个
  - 关键字不能用于自定义名字，只能在特定语法结构中使用。 
  - [参考解释](https://www.php.cn/be/go/443370.html)
  1. for
  2. range
  3. break
  4. continue
  5. switch
  6. case
  7. default
  8. fallthrough (switch case中默认有break，加fallthrough可以避免跳出)
  9. const
  10. import
  11. package
  12. type
  13. var
  14. struct
  15. interface
  16. map
  17. if
  18. else
  19. goto
  20. defer
  21. func
  22. return
  23. go (goroutine)
  24. chan
  25. select
- 此外，还有大约30多个**预定义**的名字，比如int和true等
  - 具体参考[builtin包](https://pkg.go.dev/builtin)
  - 内建常量 
    - true
    - false
    - iota
    - nil
  - 内建类型
    1. int
    2. int8
    3. int16
    4. int32
    5. int64
    6. uint
    7. uint8
    8. uint16
    9. uint32
    10. uintptr
    11. float32
    12. float64
    13. complex64
    14. complex128
    15. bool
    16. byte
    17. rune
    18. string
    19. error
  - 内建函数
    1. make
    2. len
    3. cap (返回数组Array的长度、slice的最大容量、chan的buffer容量)
    4. new
    5. append
    6. copy
    7. close
    8. delete (删除map的key)
    9. complex
    10. real
    11. imag (返回复数的虚数部分)
    12. panic
    13. recover
- 如果一个名字是在函数**内部定义**，那么它就只在函数**内部有效**。
- 如果是在函数外部定义，那么将在**当前包的所有文件中都可以访问**。
- 名字的**开头字母的大小写**决定了名字在**包外的可见性**。

### 2.2. 声明
- 声明语句定义了程序的各种**实体对象**以及**部分或全部的属性**
- Go语言主要有四种类型的声明语句：
  - var 变量
  - const 常量
  - type 类型
  - func 函数
- 一个Go语言编写的程序对应**一个或多个**以`.go`为文件后缀名的源文件
  - 每个源文件中以**包的声明语句**开始，说明该源文件是属于哪个包
  - 包声明语句之后是`import`语句导入依赖的其它包，
  - 然后是**包一级**的类型、变量、常量、函数的声明语句，包一级的各种类型的**声明语句的顺序无关紧要**

### 2.3. 变量
- `var 变量名字 类型 = 表达式 `
  - 其中**类型**或`= 表达式`两个部分**可以省略其中的一个**。
  - 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息
  - 如果初始化表达式被省略，那么将用**零值初始化**该变量。
    - 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中**不存在未初始化的变量。**

#### 2.3.1. 简短变量声明
- 它以`名字 := 表达式`形式声明变量，变量的类型根据表达式来自动推导。
- 简短变量声明左边的变量**可能并不是全部都是刚刚声明的**。如果有一些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过的变量就只有**赋值行为**了
  - 所以**必须要是可赋值类型**，不能变成其他类型
- 简短变量声明语句中必须**至少要声明一个新的变量**

#### 2.3.2. 指针
- 一个变量对应一个保存了变量对应类型值的内存空间。
- 一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。
  - 并不是每一个值都会有一个内存地址，但是对于**每一个变量必然有对应的内存地址**
- 如果用`var x int`声明语句声明一个x变量，那么`&x`表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，
  - 指针对应的数据类型是 `*int` ，指针被称之为`指向int类型的指针`。如
- 同时 `*p` 表达式对应p指针指向的变量的值。一般 `*p` 表达式读取指针指向的变量的值
- 对于**聚合类型每个成员**——比如结构体的每个字段、或者是数组的每个元素——**也都是对应一个变量**，因此**可以被取地址**。
- 变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么**表达式也必须能接受 & 取地址操作**。
- 任何类型的指针的零值都是nil。
- 在Go语言中，**返回函数中局部变量的地址也是安全的**。只要外部有引用，局部变量地址在被返回之后依然有效

#### 2.3.3. new函数
- 另一个创建变量的方法是调用内建的`new`函数。表达式`new(T)`将创建一个T类型的**匿名变量**，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T 。
- 换言之，new函数类似是一种**语法糖**，而**不是一个新的基础概念**。
  - 用`new`**创建变量**和**普通变量声明**语句方式创建变量**没有什么区别**
- 每次调用new函数都是返回一个新的变量的地址
  - 当然也可能有特殊情况：如果**两个类型都是空的**，也就是说**类型的大小是0**，例如 `struct{}` 和 `[0]int` ，有可能有相同的地址（依赖具体的语言实现）
  - **谨慎使用大小为0的类型**，因为如果类型的大小为0的话，可能导致**Go语言的自动垃圾回收器**有不同的行为，具体请查看 `runtime.SetFinalizer` 函数相关文档

#### 2.3.4. 变量的生命周期
- 变量的生命周期指的是**在程序运行期间变量有效存在的时间段**
  - 对于在**包一级声明的变量**来说，它们的生命周期**和整个程序的运行周期是一致的**
  - 而相比之下，**局部变量**的生命周期则是**动态的**：每次从创建一个新变量的声明语句开始，直到该变量**不再被引用**为止，然后变量的存储空间可能被回收
    - **函数的参数变量和返回值变量都是局部变量**。它们在函数每次被调用的时候创建。
- Go语言的自动垃圾收集器机制
  - **每个包级的变量**和**每个当前运行函数的每一个局部变量**开始，通过指针或引用的访问路径遍历，**是否可以找到该变量**。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果
- 因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期**可能超出其局部作用域**。同时，**局部变量可能在函数返回之后依然存在**。
- **编译器**会自动选择在**栈**上还是在**堆**上分配局部变量的存储空间
  - 当`f()`函数中的`x`被外部引用后，因为它在函数退出后依然可以通过外部变量找到，虽然它是在函数内部定义的；
  - 用Go语言的术语说，这个`x`局部变量从`函数f`中**逃逸了**。

### 2.4. 赋值
- 数值变量也可以支持 `++` 递增和 `--` 递减语句（译注：自增和自减是语句，而不是表达式，因此 x = i++ 之类的表达式是错误的）

#### 2.4.1. 元组赋值
- 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。
- 在赋值之前，赋值语句右边的所有表达式将会**先进行求值**，然后再统一更新左边对应变量的值。
- 和变量声明一样，我们可以用下划线空白标识符 _ 来丢弃不需要的值
  - `_`**不被认为是个变量**
    - `_:=1`会返回左边**没有新变量声明**

#### 2.4.2. 可赋值性
- 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为
- 不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值**必须有相同的数据类型**。更直白地说，只有右边的值对于左边的变量**是可赋值的**，赋值语句才是允许的。
- 可赋值性的规则**对于不同类型有着不同要求**，对每个新类型特殊的地方我们会专门解释。
- 对于两个值是否可以用 `==` 或 `!=` 进行相等比较的能力也和可赋值能力有关系

### 2.5. 类型
- 变量或表达式的类型定义了**对应存储值的属性特征**，例如**数值在内存的存储大小**（或者是元素的bit个数），它们在**内部是如何表达的**，是否支持一些**操作符**，以及它们自己**关联的方法集**等。
- 一**个类型声明语句创建了一个新的类型名称**，和现有类型具有**相同的底层结构**。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。 `type 类型名字 底层类型`
- 对于每一个类型T，都有一个对应的类型转换操作`T(x)`，用于将`x`转为T类型
- 数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的
- 在任何情况下，**运行时不会发生转换失败的错误**（译注:错误**只会发生在编译阶段**）。
- **底层数据类型**决定了**内部结构和表达方式**，也决定是否可以像底层类型一样**对内置运算符的支持**
- 一个命名的类型可以提供**书写方便**
- 命名类型还可以**为该类型的值定义新的行为**。
  
### 2.6. 包和文件
- Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持**模块化**、**封装**、**单独编译**和**代码重用**
- 每个包都对应一个**独立的名字空间**
- 包还可以让我们通过控制哪些名字是外部可见的来**隐藏内部实现信息**
- 每个源文件都是**以包的声明语句开始**，用来指明包的名字
- 如果包注释很大，通常会放到一个独立的`doc.go`文件中。

#### 2.6.1. 导入包
- 在Go语言程序中，每个包都有一个**全局唯一的导入路径**
  - Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由**构建工具**来解释的
- 导入的包也可以绑定到另一个名称，以避免名字冲突

#### 2.6.2. 包的初始化
- 包的初始化首先是解决包级变量的**依赖顺序**，然后按照包级变量**声明出现的顺序依次**初始化：
- 如果包中含有**多个.go源文件**，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件**根据文件名排序**，然后**依次调用编译器编译**
- 我们可以用一个特殊的`init`初始化函数来简化初始化工作。每个文件都可以包含**多个init初始化函数**
- 每个包在解决依赖的前提下，以导入声明的顺序初始化，**每个包只会被初始化一次**。
- 初始化工作是自下而上进行的，`main`包最后被初始化
  
### 2.7. 作用域
- 声明语句的作用域是指**源代码中可以有效使用这个名字的范围**
- 不要将**作用域**和**生命周期**混为一谈。
  - 作用域对应的是一个源代码的文本区域；它是一个**编译时的属性**
  - 生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个**运行时的概念**
- 句法块是由**花括弧**所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。
- 句法块内部声明的名字是**无法被外部块访问的**。
- 我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为**词法块**。
  - 对**全局的源代码**来说，存在一个整体的词法块，称为**全局词法块**；
  - 对于每个包；每个**for、if和switch语句**，也都有对应词法块；
  - 每个**switch或select**的分支也有独立的词法块；当然也包括显式书写的词法块
- **声明语句对应的词法域决定了作用域范围的大小。**
- 一个程序可能包含**多个同名的声明**，只要它们在**不同的词法域**就没有关系
- 当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程**从最内层的词法域向全局的作用域进行**。
  - 如果查找失败，则报告**“未声明的名字”**这样的错误
  - 比如错把`:=`写成`=`
- 在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明
- 在**包级别**，**声明的顺序并不会影响作用域范围**，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。
  - 但是如果一个变量或常量递归**引用了自身**，则会产生**编译错误**。