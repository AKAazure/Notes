## 第3章　基础数据类型
- Go语言将数据类型分为四类：**基础类型**、**复合类型**、**引用类型**和**接口类型**。
- **复合数据类型**是通过**组合简单类型**，来表达更加复杂的数据结构
- 用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是**对程序中一个变量或状态的间接引用**。
  - 这意味着对任一引用类型数据的修改**都会影响所有该引用的拷贝**
  - 

### 3.1. 整型
- Go语言的数值类型包括几种不同大小的整数、浮点数和复数。
- 这里还有两种一般**对应特定CPU平台机器字大小**的有符号和无符号整数`int`和`uint`；其中int是应用最广泛的数值类型。
- Unicode字符`rune`类型是和`int32`**等价的类型**，通常用于表示一个**Unicode码点**。这两个名称可以互换使用
- 还有一种无符号的整数类型`uintptr`，**没有指定具体的bit大小**但是**足以容纳指针**。
  - uintptr类型只有在**底层编程**时才需要，特别是Go语言和**C语言函数库或操作系统接口**相交互的地方。
- 下面是Go语言中关于算术运算、逻辑运算和比较运算的**二元运算符**，它们按照优先级递减的顺序排列：
    1. `* / % << >> & &^` 
       1. 注意%取余的优先级
       2. &^ 是 NAND 
    2. `+ - | ^` 
       1. `^`是XOR，**Golang没有幂运算二元运算符**
    3. `== != < <= > >=`
    4. `&&`
    5. `||`
- 二元运算符有**五种优先级**。在同一个优先级，使用左优先结合规则
- 一个算术运算的结果，不管是有符号或者是无符号的，如果**需要更多的bit位**才能正确表示的话，就说明计算结果是**溢出了**
  - 超出的高位的bit位部分将被**丢弃**。
- 对于整数，`+x`是`0+x`的简写，`-x`则是`0-x`的简写；对于浮点数和复数，`+x`就是`x`，`-x`则是x的负数
- 在 `x<<n` 和 `x>>n` 移位运算中，决定了移位操作的bit数部分必须是无符号数
- 尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是**倾向于使用有符号的int类型**
  - 比如，内置的`len`函数返回一个有符号的int，
    - 所以可以 `for i:=len($slice)-1;i>=0;i--{}` 也不至于因为uint无法处理0-1出错
  - **无符号数**往往只有在**位运算**或其它**特殊的运算场景**才会使用
- 一般来说，需要一个**显式的转换**将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的**二元操作**中**必须是相同的类型**。
- 对于每种类型T，如果转换**允许**的话，类型转换操作`T(x)`将x转换为T类型。
  - 许多**整数之间**的相互转换**并不会改变数值**；它们只是**告诉编译器如何解释这个值**。
  - 浮点数到整数的转换将**丢失任何小数部分**，然后向数轴零方向截断
  - 任何大小的整数字面值都可以用以**0开始的八进制格式**书写，例如0666；或用以**0x或0X开头的十六进制格式书写**，例如0xdeadbeef。
    - 所以`010`只能是8，而不是10
- 字符面值通过一对**单引号**直接包含对应字符，单引号string literal是rune/int32类型
  - `fmt.Printf("%T %T",'c','国') // "int32 int32"`

### 3.2. 浮点数
- Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由**IEEE754**浮点数国际标准定义，该浮点数规范被所有现代的CPU支持
  - 32精度
    - 1 S
    - 8 Exp
    - 23 Frac
  - 64精度
    - 1 S
    - 11 Exp
    - 52 Frac
  - 这些浮点数类型的取值范围可以从**很微小到很巨大**。
  - 常量`math.MaxFloat32`表示float32能表示的最大数值，大约是`3.4e38`；对应的`math.MaxFloat64`常量大约是`1.8e308`。它们分别能表示的最小值近似为`1.4e-45`和`4.9e-324`。
- math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：
  - **正无穷大和负无穷大**，分别用于**表示太大溢出的数字**和**除零**的结果；
  - 还有**NaN非数**，一般用于表示无效的除法操作结果**0/0**或**Sqrt(-1)**.
    - 函数`math.IsNaN`用于测试一个数**是否是非数NaN**，`math.NaN`则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，**因为NaN和任何数都是不相等的**
      - ```nan := math.NaN(); fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"```
- 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，因为浮点数比较要小心

### 3.3. 复数
- Go语言提供了两种精度的复数类型：`complex64`和`complex128`，分别对应`float32`和`float64`两种浮点数精度。
- 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的
  - （译注：浮点数的相等比较是危险的，需要特别**小心处理精度问题**）。

### 3.4. 布尔型
- 一个布尔类型的值只有两种：`true`和`false`
- 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换
  - `func itob(i int) bool {return i!=0}`
  - `func btoi(b bool) int {if b {return 1} return 0}`
  
### 3.5. 字符串
- 一个字符串是一个**不可改变的字节序列**。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。
- 文本字符串通常被解释为采用**UTF8编码**的Unicode码点`rune`序列
- 内置的`len`函数可以返回一个字符串中的**字节数目**（不是rune字符数目）
- 第i个字节并不一定是字符串的第i个字符，因为对于**非ASCII字符的UTF8编码**会要两个或多个字节。
- 字符串可以用==和<进行比较；比较通过**逐个字节**比较完成的，因此比较的结果是字符串自然编码的顺序。
- 字符串的值是**不可变**的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值
- 不变性意味着如果**两个字符串共享相同的底层数据的话也是安全的**，这使得**复制任何长度的字符串代价是低廉的**

#### 3.5.1. 字符串面值
- 在一个双引号包含的字符串面值中，可以用以反斜杠`\`开头的转义序列插入**任意的数据**
  - 一个十六进制的转义形式是 `\xhh` ，其中两个h表示十六进制数字（大写或小写都可以）。
  - 一个八进制转义形式是 `\ooo `，包含**三个八进制的o数字（0到7）**，但是不能超过 `\377` (255)
- 一个原生的字符串面值形式是\`...\`，使用**反引号**代替双引号。
  - 在原生的字符串面值中，**没有转义操作**；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值**可能跨越多行**
- 原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于**HTML模板**、**JSON面值**、**命令行提示信息**以及那些需要扩展到多行的场景。

#### 3.5.2. Unicode
- **每个符号**都分配一个**唯一的Unicode码点**，Unicode码点对应Go语言中的`rune`整数类型
- 通用的表示一个Unicode码点的数据类型是`int32`，也就是Go语言中**rune对应的类型**；它的同义词rune符文正是这个意思。

#### 3.5.3. UTF-8
- UTF8是一个将Unicode码点编码为字节序列的变长编码。
  - 使用**1到4个字节**来表示每个Unicode码点，
    - ASCII部分字符只使用1个字节，
    - 常用字符部分使用2或3个字节表示
  - 每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节
    - `0xxxxxxx runes 0-127 (ASCII)`
    - `110xxxxx 10xxxxxx 128-2047 (values <128 unused)`
    - `1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values <2048 unused)`
    - `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused)`
- 变长的编码**无法直接通过索引来访问第n个字符**，但是UTF8编码获得了很多额外的优点
  - 首先UTF8编码比较紧凑，**完全兼容ASCII码**，并且可以**自动同步**
- `unicode`包提供了诸多处理`rune`字符相关功能的函数
  - `unicode/utf8`包则提供了用于`rune`字符序列的`UTF8`**编码**和**解码**的功能。\
  - 每一次调用`utf8.DecodeRuneInString`函数都返回一个r和长度，
    - r对应字符本身，
    - 长度对应r采用UTF8编码后的编码字节数目
- 有很多Unicode字符**很难直接从键盘输入**，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符
  - Go语言字符串面值中的**Unicode转义字符**让我们可以通过Unicode码点输入特殊的字符。
- 正如我们前面提到的，文本字符串采用UTF8编码**只是一种惯例**
  - 如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编码的UTF8数据将生成一个特别的Unicode字符 `\uFFFD` ，在印刷中这个符号通常是一个**黑色六角或钻石形状**，里面包含一个**白色的问号**"?"。

#### 3.5.4. 字符串和Byte切片
- 标准库中有四个包对字符串处理尤为重要：`bytes`、`strings`、`strconv`和`unicode`包。
  - strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
  - bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型
  - strconv包提供了布尔型、整型数、浮点数和对应字符串的**相互转换**，还提供了**双引号转义相关**的转换
  - unicode包提供了`IsDigit`、`IsLetter`、`IsUpper`和`IsLower`等类似功能，它们用于给字符分类。ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换

#### 3.5.5. 字符串和数字的转换
- 将一个整数转为字符串，一种方法是用`fmt.Sprintf`返回一个格式化的字符串；另一个方法是用`strconv.Itoa($int)`：
- FormatInt和FormatUint函数可以用**不同的进制**来格式化数字：
  - `fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"`
- 如果要将一个字符串解析为整数，可以使用`strconv`包的`Atoi`或`ParseInt`函数，还有用于解析无符号整数的`ParseUint`函数
  - `x, err := strconv.Atoi("123") // x is an int`
  - `y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits`
    - ParseInt函数的第三个参数是用于指定整型数的大小；
- 有时候也会使用`fmt.Scanf`来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以**灵活处理不完整或不规则的输入**。

### 3.6. 常量
- 常量表达式的值在**编译期**计算，而不是在运行期。每种常量的**潜在类型都是基础类型**：boolean、string或数字。
- 所有常量的运算都可以在编译期完成，这样可以**减少运行时的工作**，也**方便其他编译优化**
- **当操作数是常量时**，一些运行时的错误也**可以在编译时被发现**，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等
- **常量间的所有算术运算、逻辑运算和比较运算的结果也是常量**，对常量的类型转换操作或以下函数调用都是返回常量结果：`len`、`cap`、`real`、`imag`、`complex`和`unsafe.Sizeof`
- 因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定**数组**类型的**长度**   
    -  ```Go
        const IPv4Len = 4
        // parseIPv4 parses an IPv4 address (d.d.d.d).
        func parseIPv4(s string) IP {
        var p [IPv4Len]byte
        // ...
        }
        ```
#### 3.6.1. iota 常量生成器
- 常量声明可以使用`iota`常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。
  - 在一个const声明语句中，在第一个声明的常量所在的行，`iota`将会被置为`0`，然后在**每一个有常量声明的行加一**。
  - ```Go
        type Weekday int
        const (
            Sunday Weekday = iota
            Monday
            Tuesday
            Wednesday
            Thursday
            Friday
            Saturday
        )
     ```
  - 周日将对应0，周一为1，如此等等。
-  我们也可以在复杂的常量表达式中使用iota，
   - ```Go
        type Flags uint
            const (
            FlagUp Flags = 1 << iota // is up
            FlagBroadcast // supports broadcast access capability
            FlagLoopback // is a loopback interface
            FlagPointToPoint // belongs to a point-to-point link
            FlagMulticast // supports multicast access capability
        )
        ```
    
#### 3.6.2. 无类型常量
- Go语言的常量有个**不同寻常之处**。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是**许多常量并没有一个明确的基础类型**。
  - 编译器为这些没有明确基础类型的数字常量提供**比基础类型更高精度的算术运算**；你可以认为至少有**256bit的运算精度**
- 这里有**六种未明确类型的常量类型**，分别是
  - 无类型的布尔型、
  - 无类型的整数、
  - 无类型的字符、
  - 无类型的浮点数、
  - 无类型的复数、
  - 无类型的字符串。
- 无类型的常量不仅可以提供更高的运算精度，而且可以**直接用于更多的表达式而不需要显式的类型转换**。
  - 比如可以正确计算 $2^{200}/2^{198}$ (这两个都超出int64或是uint64的范围了)
    - ```fmt.Println((2<<200)/(2<<198)) // "4"```
- **只有常量可以是无类型的**。
  - 当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被**隐式转换**为对应的类型，如果转换合法的话。
- 注意有一点不同：**无类型整数常量**转换为`int`，**它的内存大小是不确定的**，但是**无类型浮点数和复数常量**则转换为内存大小明确的`float64`和`complex128`。
  - 如果不知道浮点数类型的内存大小是**很难写出正确的数值算法的**，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。